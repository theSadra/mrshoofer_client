# Nuclear option: completely bypassing NextAuth env var checks
FROM node:20-alpine

WORKDIR /app

# Copy package files first
COPY package.json package-lock.json ./

# Remove postinstall script
RUN sed -i '/postinstall/d' package.json

# Install dependencies
RUN npm install

# Copy application code
COPY . .

# Create a patch file that will modify NextAuth's internal checks
RUN echo 'console.log("🔧 Patching NextAuth to bypass secret check...");\n\
const fs = require("fs");\n\
const path = require("path");\n\
\n\
// Find the nextauth module path\n\
const nextauthDir = path.resolve("./node_modules/next-auth");\n\
\n\
// Look for files that might contain the SECRET check\n\
const filesToCheck = [\n\
  "index.js",\n\
  "core/index.js",\n\
  "core/lib/jwt.js",\n\
  "jwt/index.js",\n\
];\n\
\n\
// The secret we want to hardcode\n\
const hardcodedSecret = "vK8mN2pQ7rS9tU6wX3yZ5aB8cE1fH4iL7oP0qR3sT6uV9xA2bD5gJ8kM1nQ4rU7w";\n\
\n\
// Function to patch a file\n\
function patchFile(filePath) {\n\
  if (!fs.existsSync(filePath)) {\n\
    console.log(`File not found: ${filePath}`);\n\
    return false;\n\
  }\n\
\n\
  let content = fs.readFileSync(filePath, "utf8");\n\
  const originalContent = content;\n\
\n\
  // Different patterns to look for and replace\n\
  const patterns = [\n\
    // Pattern 1: Check for the NO_SECRET error\n\
    {\n\
      search: /if\\s*\\(!secret\\)\\s*\\{[^}]*throw new Error\\([\'"]NO_SECRET[\'"]\\)/gs,\n\
      replace: "if (!secret) { secret = \\"" + hardcodedSecret + "\\""\n\
    },\n\
    // Pattern 2: Directly setting the secret\n\
    {\n\
      search: /const\\s+secret\\s*=\\s*options\\.secret/g,\n\
      replace: "const secret = options.secret || \\"" + hardcodedSecret + "\\""\n\
    },\n\
    // Pattern 3: Another pattern for secret check\n\
    {\n\
      search: /if\\s*\\(typeof\\s+secret\\s+!==\\s+[\'"]string[\'"]\\)\\s*\\{[^}]*\\}/gs,\n\
      replace: "if (typeof secret !== \\"string\\") { secret = \\"" + hardcodedSecret + "\\" }"\n\
    }\n\
  ];\n\
\n\
  // Apply all patterns\n\
  let modified = false;\n\
  patterns.forEach(pattern => {\n\
    if (pattern.search.test(content)) {\n\
      content = content.replace(pattern.search, pattern.replace);\n\
      modified = true;\n\
    }\n\
  });\n\
\n\
  // Write back if modified\n\
  if (modified) {\n\
    fs.writeFileSync(filePath, content);\n\
    console.log(`✅ Patched ${filePath}`);\n\
    return true;\n\
  }\n\
\n\
  console.log(`⚠️ No matching patterns found in ${filePath}`);\n\
  return false;\n\
}\n\
\n\
// Search recursively through all JS files\n\
function searchAndPatchRecursively(dir, depth = 0, maxDepth = 3) {\n\
  if (depth > maxDepth) return;\n\
  \n\
  const files = fs.readdirSync(dir);\n\
  \n\
  for (const file of files) {\n\
    const filePath = path.join(dir, file);\n\
    const stat = fs.statSync(filePath);\n\
    \n\
    if (stat.isDirectory()) {\n\
      searchAndPatchRecursively(filePath, depth + 1, maxDepth);\n\
    } else if (file.endsWith(".js")) {\n\
      const content = fs.readFileSync(filePath, "utf8");\n\
      if (content.includes("NO_SECRET") || content.includes("options.secret") || \n\
          content.includes("jwt") || content.includes("JWT")) {\n\
        console.log(`Checking ${filePath}...`);\n\
        patchFile(filePath);\n\
      }\n\
    }\n\
  }\n\
}\n\
\n\
// Try patching the specific files we know might contain the check\n\
let patchedAny = false;\n\
for (const file of filesToCheck) {\n\
  const filePath = path.join(nextauthDir, file);\n\
  patchedAny = patchFile(filePath) || patchedAny;\n\
}\n\
\n\
// If we didn\'t patch any of the expected files, search recursively\n\
if (!patchedAny) {\n\
  console.log("No patches applied to expected files, searching recursively...");\n\
  searchAndPatchRecursively(nextauthDir);\n\
}\n\
\n\
console.log("NextAuth patching completed!");\n\
' > patch-nextauth.js

# Execute the patch
RUN node patch-nextauth.js

# Create .env files
RUN echo "NEXTAUTH_SECRET=vK8mN2pQ7rS9tU6wX3yZ5aB8cE1fH4iL7oP0qR3sT6uV9xA2bD5gJ8kM1nQ4rU7w" > .env && \
    echo "NEXTAUTH_URL=https://mrshoofer-client.liara.run" >> .env && \
    cp .env .env.local && cp .env .env.production

# Generate Prisma client and build
RUN npx prisma generate
RUN npm run build

# Create startup script
RUN echo '#!/bin/sh\n\
export NEXTAUTH_SECRET="vK8mN2pQ7rS9tU6wX3yZ5aB8cE1fH4iL7oP0qR3sT6uV9xA2bD5gJ8kM1nQ4rU7w"\n\
export NEXTAUTH_URL="https://mrshoofer-client.liara.run"\n\
\n\
echo "Starting application with hardcoded NextAuth secret"\n\
exec npm start\n\
' > start.sh

# Make the startup script executable
RUN chmod +x start.sh

# Expose port
EXPOSE 3000

# Start the application using the startup script
CMD ["./start.sh"]
